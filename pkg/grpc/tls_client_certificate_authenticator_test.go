package grpc_test

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"encoding/pem"
	"testing"
	"time"

	"github.com/buildbarn/bb-storage/internal/mock"
	bb_grpc "github.com/buildbarn/bb-storage/pkg/grpc"
	"github.com/buildbarn/bb-storage/pkg/testutil"
	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/require"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/peer"
	"google.golang.org/grpc/status"
)

var (
	// Certificates generated by running:
	// openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:4096 -keyout key -out crt
	certificateValid = parseCertificate(`
-----BEGIN CERTIFICATE-----
MIIErDCCApQCCQD1JkdW4BeeJTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1h
LmV4YW1wbGUuY29tMB4XDTE5MTExODA5MDMzNFoXDTIwMTExNzA5MDMzNFowGDEW
MBQGA1UEAwwNYS5leGFtcGxlLmNvbTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCC
AgoCggIBALk5cT5DP+rBMPooqo1Yeq83qLKssOWIUSyplWMn6ZL2HioPKZpAmI3t
fVfY5NK7wvGvRKWDrjQvf3UjLRKwUFoFXLoWUo/1hreVUN92PwNuH7Q/nMBSepKD
Z/jkWk3Tkx/t1GWtgKWl4KnNtYoLoMx0t+9ooq6YzTNcCU821MYMucfc7lRmAhCK
3Qk8TwalYMHCw+h0/4yie/ZzTXiWsK0GtMKcHWMof4eOXBrqpy+xe2FcRYsKOB5N
kbRoBgKHrHp4AkUtZ5suLsTlQZMQqvu2Y8bHF6qFEm5iDrSsE932nElqPANRMFtP
YHry8yur5rHXHJVBvUvcpaxRBlbuZc5gm1U3mjfLA1BS6Xa/fAcg9Dp0X9nJZ1mp
8loDs4LaO9ZeVfKUTiFLwfHStq3zx09OQflwN/pFg3MCcuZ759FYVtjGeoGuSPvR
Ywh5TJK4uVL6iYeNOmaao+VY8clBkomTrnFtyjZvy1eHBkA33IG58DzJTxUZoqiQ
PtzqG+OJo2O2sdUotWB8rqf0C+qn1Fv2sx4HhCs+lBCTMpjZ/S3LyBYMqcuud6Pb
dJ7ON8HqI16e6+nkHSvkuU0yPzz2EjjPCwJTNij3Z9GoaZvhRlx6JRQmwZl80z8M
0HwmG0TNQhertiShCy8KHQyH4FVz9mfCyXbmgvduLLmLEQODJi4/AgMBAAEwDQYJ
KoZIhvcNAQELBQADggIBAHdOQqVkRAbyEHxD1yAvDiHqbtqlrKKwHc+XyMdTO8uS
JPh5PKXD4frUcZZjwBRYWe18bQm8SC5L/1XUNN583qZW3f3BppMOr8gwKAcy73lg
fL4pDjtabujh7A7+plvspdKjF89HHXPCzYwAh/Pr3PtGND1f2vs7VXutXQFziosU
Wxuw7Bm866mHIDfCpDI+Ii6Uc9JrGVObutjlzn6WXtUaCjFxI2okcTAThvdn5l3m
Uu6RQtuq11QOmfOVIADQj4rRQXIpuimOShVxSE3zkGb2F3ck4iV58Rul1G/aYyhj
07eSIdqffiOn46y0LILWpGO2rlZ57ksNapFUMhSD08X3rkXu6+RSI1sM/WTl6pBV
tv5exCNSjhdDc1Cvpco9cL5vqTRpFtOKkUvhvEOyEm3iEVthxq0aDB1Vze0zcfUw
WFBsS2ZqT6ZnJgCaXjnnf8Qz2sIuTtNCAp0zq9BsW1DY32H4/zghQymZFstG6Aew
Lyulk/txqXODRz0f0A4hLrV26W1V3PPyYUTqtQvKNBNJdUyFjK08pVeWsGYZEQCr
jig8Y4Xp76tLcc2/K6526jW7y8sM2Gx/XdGWW90O+qwwIqeUCC6Bwpuct4vrZsku
zpcXG5BVHH2dVFj+h8YRJ/Rb5aCPXmV6jDozEYiND2Fn0JCmhrm6tALdeBebspoX
-----END CERTIFICATE-----`)
	certificateUnrelated = parseCertificate(`
-----BEGIN CERTIFICATE-----
MIIErDCCApQCCQCbMI/9Uwi5vDANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1i
LmV4YW1wbGUuY29tMB4XDTE5MTExODA5MDM0MloXDTIwMTExNzA5MDM0MlowGDEW
MBQGA1UEAwwNYi5leGFtcGxlLmNvbTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCC
AgoCggIBAK+RPtbTsE+fIOBiw427ilLshva8V4GNlITh8Htt30gErp+QxzZgwv8x
U1LvMiWxT2iMc4CgrDZptwU++WqBNROfxdmtQRn98HpWxGcttguzLuUCaNc15HRM
zC9zFAFEbyEmsRh155LUOkfPM3Dk/oZyBeEhTzkTtPT/c25yKfvqD3sQseJnji4U
0qb3QV/4K0W8cyLAkFvVg8Se9JYqhYMq8RAPAV5q++jLWDbYcy38YNkw92R5mDCd
rzWErKu7/J0nhe7V56WN/GNke7rEd9HSnrT6oTzguQSQhNAAmksFLU5tZqHZSWLT
mMDzJL2zJtGTCoKgQ8vX/PcvBmQGtf+gvOSb1hI2WzqZDpsWqWQJxnvRuRceRi8G
zXY37DOKco70VjiU/xXJHRgxSZLsSnnNTTCOo/itRT108gBzRoKOzyp9wwiTQ31U
DnKTniHannAxoBI17V+B1je6zalfAyePcQg2/My+I6lXlp0LvVHf5+LKDbps0x8B
nS0zInD/yWSWGU+wTTDxsrAETqxsHUqqWlGsD1NZ88Pqw2mA5rLcTckF3guS12y6
lhWNSWD/D/F6mZBk6vNOBTvWL0Yz9S0WWm06mR6DIh6IE7l3JYkE7rapgVgcjizu
cOXEgKFFHV1yNrMG4qewlYJ0E16EXzkGiZOzsldxeLVblPX6FnCXAgMBAAEwDQYJ
KoZIhvcNAQELBQADggIBAAemJn6Ga3ksuVWbSw+vs4EHBbb+4k0sqaEckT4ODAzY
A7F/1oY8Xv4t5ZYLeCx2vwYJMA6QA5SyzFHScVlp7r5LzcCYjjPsZsEMlg9Z8N/4
CiPlPEPNj9IY43NwOGjWonYewiKs2wCOUcI4sOpNJThzOv4p6axjdfvQjAJ2lx5f
GrD4f3tlDmJSMUQs+HDwXnGLEjPkcnOaFQu0sKBfqBtAi6iXno/oNSFaNE1dhbie
3XlJ/QZ+aUwD5TA1+t6WdkSCpaqHnLw27EYmWZa1mQbZYHeGNcV5WhqhDQYF620a
HW4MVPbT28lw9VDKfAexCklZZpeGIH69oNOU9lV01ugE7R8DKbrl7vCAEo77uc4D
1/RPxjVCyOaiqWnXS6U4ZL0tmWpby94sd1duBiHIPJNIkenFKneftqMYODR39KOI
X11W5GGCYmt9pipFomH/UyefjeGn+bBsySa+wZdYW5hAXUe8kKm1b4JglqO/GvQE
3LZJy913inZGPCa7dxawgpcsNOFZLqQbi9/zlqLsqmoiElGlcmPdmcgtIDx4dSc5
Dj2jEQIEIpxsRYpW3lOv0n7Dkmq+iCCINDmp1ojESpemJXVZXJApEJeQ893FddCh
YBd2RaOw/dmr7t5l94BfD9ImQp9ab7n7cnisqev2nKPXvALBtgU3sec9jqBRVL5o
-----END CERTIFICATE-----`)
)

func parseCertificate(v string) *x509.Certificate {
	block, _ := pem.Decode([]byte(v))
	certificate, _ := x509.ParseCertificate(block.Bytes)
	return certificate
}

func TestTLSClientCertificateAuthenticator(t *testing.T) {
	ctrl, ctx := gomock.WithContext(context.Background(), t)

	clientCAs := x509.NewCertPool()
	clientCAs.AddCert(certificateValid)
	clock := mock.NewMockClock(ctrl)
	authenticator := bb_grpc.NewTLSClientCertificateAuthenticator(clientCAs, clock, nil)

	t.Run("NoGRPC", func(t *testing.T) {
		// Authenticator is used outside of gRPC, meaning it cannot
		// extract peer state information.
		_, err := authenticator.Authenticate(ctx)
		require.Equal(
			t,
			status.Error(codes.Unauthenticated, "Connection was not established using gRPC"),
			err)
	})

	t.Run("NoTLS", func(t *testing.T) {
		// Non-TLS connection.
		_, err := authenticator.Authenticate(peer.NewContext(ctx, &peer.Peer{}))
		require.Equal(
			t,
			status.Error(codes.Unauthenticated, "Connection was not established using TLS"),
			err)
	})

	t.Run("NoCertificateProvided", func(t *testing.T) {
		// Connection with no certificate provided by the client.
		_, err := authenticator.Authenticate(
			peer.NewContext(
				ctx,
				&peer.Peer{
					AuthInfo: credentials.TLSInfo{
						State: tls.ConnectionState{},
					},
				}))
		require.Equal(
			t,
			status.Error(codes.Unauthenticated, "Client provided no TLS client certificate"),
			err)
	})

	t.Run("NoCAMatch", func(t *testing.T) {
		// Connection with a certificate that doesn't match the CA.
		clock.EXPECT().Now().Return(time.Unix(1600000000, 0))
		_, err := authenticator.Authenticate(
			peer.NewContext(
				ctx,
				&peer.Peer{
					AuthInfo: credentials.TLSInfo{
						State: tls.ConnectionState{
							PeerCertificates: []*x509.Certificate{
								certificateUnrelated,
							},
						},
					},
				}))
		testutil.RequireEqualStatus(
			t,
			status.Error(codes.Unauthenticated, "Cannot validate TLS client certificate: x509: certificate signed by unknown authority"),
			err)
	})

	t.Run("Expired", func(t *testing.T) {
		// Connection with a certificate that is signed by the
		// right CA, but expired.
		clock.EXPECT().Now().Return(time.Unix(1700000000, 0))
		_, err := authenticator.Authenticate(
			peer.NewContext(
				ctx,
				&peer.Peer{
					AuthInfo: credentials.TLSInfo{
						State: tls.ConnectionState{
							PeerCertificates: []*x509.Certificate{
								certificateValid,
							},
						},
					},
				}))
		require.Equal(
			t,
			status.Error(codes.Unauthenticated, "Cannot validate TLS client certificate: x509: certificate has expired or is not yet valid: current time 2023-11-14T22:13:20Z is after 2020-11-17T09:03:34Z"),
			err)
	})

	t.Run("Success", func(t *testing.T) {
		// Connection with at least one verified chain.
		clock.EXPECT().Now().Return(time.Unix(1600000000, 0))
		_, err := authenticator.Authenticate(
			peer.NewContext(
				ctx,
				&peer.Peer{
					AuthInfo: credentials.TLSInfo{
						State: tls.ConnectionState{
							PeerCertificates: []*x509.Certificate{
								certificateValid,
							},
						},
					},
				}))
		require.NoError(t, err)
	})
}

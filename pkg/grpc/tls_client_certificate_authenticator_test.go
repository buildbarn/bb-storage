package grpc_test

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"encoding/pem"
	"testing"
	"time"

	"github.com/buildbarn/bb-storage/internal/mock"
	"github.com/buildbarn/bb-storage/pkg/auth"
	bb_grpc "github.com/buildbarn/bb-storage/pkg/grpc"
	auth_pb "github.com/buildbarn/bb-storage/pkg/proto/auth"
	"github.com/buildbarn/bb-storage/pkg/testutil"
	"github.com/golang/mock/gomock"
	"github.com/jmespath/go-jmespath"
	"github.com/stretchr/testify/require"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/peer"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/structpb"
)

var (
	// Certificates generated by running:
	// openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:4096 -keyout key -out crt -extensions extensions -config tls_client_certificate_valid.cnf
	certificateValid = parseCertificate(`
-----BEGIN CERTIFICATE-----
MIIE/jCCAuagAwIBAgIJAKTOIzLKkQ47MA0GCSqGSIb3DQEBCwUAMBgxFjAUBgNV
BAMMDWEuZXhhbXBsZS5jb20wHhcNMjIwOTI5MTczNzAyWhcNMjMwOTI5MTczNzAy
WjAYMRYwFAYDVQQDDA1hLmV4YW1wbGUuY29tMIICIjANBgkqhkiG9w0BAQEFAAOC
Ag8AMIICCgKCAgEAzhy74KXkveiBcUDHBOT9cg1cKKkhPDxd9gFGwZYHLdKdkcl4
SS19bQVo2K4snUk0cC+nTrzrka4xju4+90ZsUPzt7l6Bu9y48KbHdsgbExXq5Ofi
QCjxKGADjeVWOxvaZhJ1GpEOkVDmIoubjIs9qmn1hn6HsoptAobWg7UoVleiy7xe
tnjk+wRs1OA8F6kc9toY+xIi2kkLtvSHXs8YdZE4408zmOBYSx9MeEC2ybEvNuCA
YSez9Oykz8inWwQagB4TdShxxzCa0qngeciWx6xhPSs46OOousOWwswGeQbSKZPJ
vhE+DQHwrbn7rVN12MDAYrA5GQbiqKTqaOE120pJ6EbC7QHd7l6hPwoXVMaK8EcI
5gAEhfwOvyyN4uzXEF6MmLMXGrwibbl4mGebAjneenT5QE2+i/Wtz/HjBd7Q3/12
lqZWSHYKRr0c/aegN6BxJOXsOwsvhh7yEUCtxfdrqlK+VZFepbtT8du53Owm6lnC
vDDqogUEadgJDTbNcVIwDSVESyRXSBL2i4bQ8W18EWY2pD5p9P+3j7uzEN4YQeIZ
b5weVfXHMqCRtjO18FxQG8Uxhj1DBsxvZQ93lXemvLltIPMIJAXevCUsSMGO2dfd
HnpuUwOMAp+5TqjTtE+VgEYX2K0CdN4ktluryZrusAxQflL77BlFHkvWKTkCAwEA
AaNLMEkwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMCgGA1UdEQQhMB+C
DWEuZXhhbXBsZS5jb22BDm1lQGV4YW1wbGUuY29tMA0GCSqGSIb3DQEBCwUAA4IC
AQC43Aphw3cnQnsHI6tiQZSKYEyXa5lYhujmpnjX+LiWw6q3V+pCJ6eAZF3Cv716
1udIkJnjF/d9FbEfE38mdshYSVbxZHFjakSTtNACWhCqklMHiJ8e8tIWeDHORV93
Mc2V9oaH3TQ8xGQtdeY/sgC/rvQXV5uJArEoYNuIrSqXA5BrLaNIHUGMHyoVLoLX
7jOfLXkc+SrnG26mQv+TcDg1xOJ8ed2HY8KYZ86zB36JftelXF3xlWanubbcknuW
29EIcDFALFu0Qfe0P06msHcRt6qVnh+aOTbu0USdrh4U8p0A9uP3tAkIwoJqfaue
D6yflLid9sqpJfxAqg0vdF1YJu3Q0BoCrgR7kF+dMFgacRi0QHWUZri5gssFGUJY
3p6VpHTKClEdBj45m8IZ7ZwDMozDkcmMgW0CWeneY/d/v9nmWa4+OrHPlu6yVPJZ
sSyfNLXbToKKJUqT2xjmvBlSyfLAkXOnAV+BzV0qa6StbCdPXoX157HmKlgpCFDG
oNMiHelQZCT+P/yaEOM9THQXm3VhXZPN2aKNXs7VHB9wCEnI1jesO7cHynDGKjYJ
7tdkWZXpIRo6aQZSu+aXeb/frDFVgwici2CTiZ8JkscT0RSkje18ZRa0BisGH3U7
8LAk1RvcAzLERBYTNl2Di0GRittcxWmjwA0MtoK8r3q+0w==
-----END CERTIFICATE-----`)
	certificateUnrelated = parseCertificate(`
-----BEGIN CERTIFICATE-----
MIIE7jCCAtagAwIBAgIJAJxwu7WEgRYJMA0GCSqGSIb3DQEBCwUAMBgxFjAUBgNV
BAMMDWIuZXhhbXBsZS5jb20wHhcNMjIwOTI5MTczODQyWhcNMjMwOTI5MTczODQy
WjAYMRYwFAYDVQQDDA1iLmV4YW1wbGUuY29tMIICIjANBgkqhkiG9w0BAQEFAAOC
Ag8AMIICCgKCAgEA1IKw8e5bg1cpTpGj58PeZb1NK30IEomhATgkE2pa9jXZCU24
dY0ruq1Ln4bm4d2KEXZWtvsFltQXJF1Ck2RpsGKTrVeEuk/n8P7qdJbqXENzHNuL
m4KLgPTRbLNKWzfBNiZU8m6GW8TonNhKV/1LF4+DdSgrv++ow20ggl00G10fhGty
eLj1CW2dpwCspgW+ocnCwkWwLRdDVtmarrO/R1zPqL1DYxcsgY8moRjW/0q0vCbR
q/tqRjguz0b3ttkcvmx2ZiTUlaXjUaO4wdzEtfZRI6htLESX5a2Z8Ljpf3U/B4K3
5V0SPEdT3Sf7oHlhvxbwcz4o3pKKJX0h9bqmPwCJXfcm7rfoDfwkpgE02OVSvSax
5JA6NytjPx3SU51nNp8Hs6LGH8jjmksox1Bi7lWzMEBsKq2nmocExPSSqdR92a/5
blxTxr7HAKMopiyKJwNltDpAqkSkQK4+NrW9ShLS4diSnown0UeTvjH+1OdRqxcT
bZVybyRPpzDudtUQdyPxfnJJWVqcSuzFCUw2q1qKIIIZP5zRhUTmgKpmC0zX36ot
JGclYheAgHbdedTQkSbrua8TFTAVuov2x6Y9JlmvYQYc2FQ9kIO18U4/n60yI13M
q4slkoxfk4jizOaNm7G5PhOc6WKGOmopMLTyKhJLOewSmgxa1uSGaA6mybUCAwEA
AaM7MDkwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMBgGA1UdEQQRMA+C
DWIuZXhhbXBsZS5jb20wDQYJKoZIhvcNAQELBQADggIBAGkGoI3wWYi450yIXF46
o981OOi+0Ha2rdF4nlUzpZl9kzL0qj4UFhnuLv6I28rdTBkdLGvZEn9wgScTPOkH
y0yCsELwrozzCxMvMJt/hKADEOTdctmPp8pv9nwTdcJnpC49eNzb3BAJCQVv1Psw
ur6ttovjeG9fTLvey2UozylgRfPRY9QVrxjPSLgtRPzhkeDItVgaS5GOU95JKUHj
JM+WCJ+1wJa58JBtBpjqnyTHGFnpWc9bMAAb2Q70RMKhZj7bPs13XNQmqz+P12Z3
JDms2GBBKw2WXXGCzfD65YaECtMRhrI3C0JB0L0Tr46ZDjJ8T/kYljyfTFzDMy5r
lYQiSrFSFIebmSPMhkMcm70KhY7/wAMW0bwLqYkfcVGHDNCNy5j3IOwOWdkiGKQJ
nbP7p8wd9uP9btADa/8V8XJxJv04NXr0U2+Z2/ileQcRHio2qe8qfqLoNz5uSB92
4bX7UaNXluPQqCpThV5gjU6hw3P8dZS4BpR3EcApiFfW5pOHiHWfkcdDaHLtCS3S
jCT2r8oxuQ/nUW/TlVh4baequDpFnA4sqIR0DbJM3OGy3kOhElAPMbggLWAJIpcp
DKDJE7E+7r9RuZlq7uly0UpI+KzvsTxqSlSUIt1djPflrdRCQ+aRd6VH2tfcU2Hh
8jD/UnfO3BzQHOS8PYIWLW4u
-----END CERTIFICATE-----`)
)

func parseCertificate(v string) *x509.Certificate {
	block, _ := pem.Decode([]byte(v))
	certificate, _ := x509.ParseCertificate(block.Bytes)
	return certificate
}

func TestTLSClientCertificateAuthenticator(t *testing.T) {
	ctrl, ctx := gomock.WithContext(context.Background(), t)

	clientCAs := x509.NewCertPool()
	clientCAs.AddCert(certificateValid)
	clock := mock.NewMockClock(ctrl)
	expectedMetadata := auth.MustNewAuthenticationMetadataFromProto(&auth_pb.AuthenticationMetadata{
		Public: structpb.NewStructValue(&structpb.Struct{
			Fields: map[string]*structpb.Value{
				"dnsNames": structpb.NewListValue(&structpb.ListValue{
					Values: []*structpb.Value{
						structpb.NewStringValue("a.example.com"),
					},
				}),
				"emailAddresses": structpb.NewListValue(&structpb.ListValue{
					Values: []*structpb.Value{
						structpb.NewStringValue("me@example.com"),
					},
				}),
			},
		}),
	})

	aValidator := jmespath.MustCompile(`contains(dnsNames, 'a.example.com')`)
	bValidator := jmespath.MustCompile(`contains(dnsNames, 'b.example.com')`)
	metadataExtractor := jmespath.MustCompile(`{"public": @}`)
	aAuthenticator := bb_grpc.NewTLSClientCertificateAuthenticator(clientCAs, clock, aValidator, metadataExtractor)
	bAuthenticator := bb_grpc.NewTLSClientCertificateAuthenticator(clientCAs, clock, bValidator, metadataExtractor)

	t.Run("NoGRPC", func(t *testing.T) {
		// Authenticator is used outside of gRPC, meaning it cannot
		// extract peer state information.
		_, err := aAuthenticator.Authenticate(ctx)
		testutil.RequireEqualStatus(
			t,
			status.Error(codes.Unauthenticated, "Connection was not established using gRPC"),
			err)
	})

	t.Run("NoTLS", func(t *testing.T) {
		// Non-TLS connection.
		_, err := aAuthenticator.Authenticate(peer.NewContext(ctx, &peer.Peer{}))
		testutil.RequireEqualStatus(
			t,
			status.Error(codes.Unauthenticated, "Connection was not established using TLS"),
			err)
	})

	t.Run("NoCertificateProvided", func(t *testing.T) {
		// Connection with no certificate provided by the client.
		_, err := aAuthenticator.Authenticate(
			peer.NewContext(
				ctx,
				&peer.Peer{
					AuthInfo: credentials.TLSInfo{
						State: tls.ConnectionState{},
					},
				}))
		testutil.RequireEqualStatus(
			t,
			status.Error(codes.Unauthenticated, "Client provided no TLS client certificate"),
			err)
	})

	t.Run("NoCAMatch", func(t *testing.T) {
		// Connection with a certificate that doesn't match the CA.
		clock.EXPECT().Now().Return(time.Unix(1680000000, 0))
		_, err := aAuthenticator.Authenticate(
			peer.NewContext(
				ctx,
				&peer.Peer{
					AuthInfo: credentials.TLSInfo{
						State: tls.ConnectionState{
							PeerCertificates: []*x509.Certificate{
								certificateUnrelated,
							},
						},
					},
				}))
		testutil.RequireEqualStatus(
			t,
			status.Error(codes.Unauthenticated, "Cannot validate TLS client certificate: x509: certificate signed by unknown authority"),
			err)
	})

	t.Run("Expired", func(t *testing.T) {
		// Connection with a certificate that is signed by the
		// right CA, but expired.
		clock.EXPECT().Now().Return(time.Unix(1700000000, 0))
		_, err := aAuthenticator.Authenticate(
			peer.NewContext(
				ctx,
				&peer.Peer{
					AuthInfo: credentials.TLSInfo{
						State: tls.ConnectionState{
							PeerCertificates: []*x509.Certificate{
								certificateValid,
							},
						},
					},
				}))
		testutil.RequireEqualStatus(
			t,
			status.Error(codes.Unauthenticated, "Cannot validate TLS client certificate: x509: certificate has expired or is not yet valid: current time 2023-11-14T22:13:20Z is after 2023-09-29T17:37:02Z"),
			err)
	})

	t.Run("ValidationFail", func(t *testing.T) {
		// Connection with a certificate that is signed by the
		// right CA, but expired.
		clock.EXPECT().Now().Return(time.Unix(1680000000, 0))

		_, err := bAuthenticator.Authenticate(
			peer.NewContext(
				ctx,
				&peer.Peer{
					AuthInfo: credentials.TLSInfo{
						State: tls.ConnectionState{
							PeerCertificates: []*x509.Certificate{
								certificateValid,
							},
						},
					},
				}))
		testutil.RequireEqualStatus(
			t,
			status.Error(codes.Unauthenticated, "Rejected TLS client certificate claims"),
			err)
	})

	t.Run("Success", func(t *testing.T) {
		// Connection with at least one verified chain.
		clock.EXPECT().Now().Return(time.Unix(1680000000, 0))
		actualMetadata, err := aAuthenticator.Authenticate(
			peer.NewContext(
				ctx,
				&peer.Peer{
					AuthInfo: credentials.TLSInfo{
						State: tls.ConnectionState{
							PeerCertificates: []*x509.Certificate{
								certificateValid,
							},
						},
					},
				}))
		require.NoError(t, err)
		require.Equal(t, expectedMetadata, actualMetadata)
	})
}

diff --git mockgen/model/model.go mockgen/model/model.go
index 853dbf2..0306d59 100644
--- mockgen/model/model.go
+++ mockgen/model/model.go
@@ -337,28 +337,44 @@ func (tp *TypeParametersType) addImports(im map[string]bool) {
 
 // The following code is intended to be called by the program generated by ../reflect.go.
 
-// InterfaceFromInterfaceType returns a pointer to an interface for the
-// given reflection interface type.
-func InterfaceFromInterfaceType(it reflect.Type) (*Interface, error) {
-	if it.Kind() != reflect.Interface {
-		return nil, fmt.Errorf("%v is not an interface", it)
-	}
+// InterfaceFromInterfaceOrFuncType returns a pointer to an interface for the
+// given reflection interface or function type.
+func InterfaceFromInterfaceOrFuncType(it reflect.Type) (*Interface, error) {
 	intf := &Interface{}
 
-	for i := 0; i < it.NumMethod(); i++ {
-		mt := it.Method(i)
-		// TODO: need to skip unexported methods? or just raise an error?
+	switch it.Kind() {
+	case reflect.Interface:
+		for i := 0; i < it.NumMethod(); i++ {
+			mt := it.Method(i)
+			// TODO: need to skip unexported methods? or just raise an error?
+			m := &Method{
+				Name: mt.Name,
+			}
+
+			var err error
+			m.In, m.Variadic, m.Out, err = funcArgsFromType(mt.Type)
+			if err != nil {
+				return nil, err
+			}
+
+			intf.AddMethod(m)
+		}
+	case reflect.Func:
+		// For function types, generate an interface having a single
+		// "Call" method.
 		m := &Method{
-			Name: mt.Name,
+			Name: "Call",
 		}
 
 		var err error
-		m.In, m.Variadic, m.Out, err = funcArgsFromType(mt.Type)
+		m.In, m.Variadic, m.Out, err = funcArgsFromType(it)
 		if err != nil {
 			return nil, err
 		}
 
 		intf.AddMethod(m)
+	default:
+		return nil, fmt.Errorf("%v is not an interface or function type", it)
 	}
 
 	return intf, nil
diff --git mockgen/reflect.go mockgen/reflect.go
index ca80ebb..2baed3d 100644
--- mockgen/reflect.go
+++ mockgen/reflect.go
@@ -224,7 +224,7 @@ func main() {
 	}
 
 	for _, it := range its {
-		intf, err := model.InterfaceFromInterfaceType(it.typ)
+		intf, err := model.InterfaceFromInterfaceOrFuncType(it.typ)
 		if err != nil {
 			fmt.Fprintf(os.Stderr, "Reflection: %v\n", err)
 			os.Exit(1)

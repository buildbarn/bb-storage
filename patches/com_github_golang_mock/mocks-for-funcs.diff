diff --git mockgen/model/model.go mockgen/model/model.go
index 88783cf..a9078fb 100644
--- mockgen/model/model.go
+++ mockgen/model/model.go
@@ -290,28 +290,44 @@ func (pt PredeclaredType) addImports(map[string]bool)              {}
 
 // The following code is intended to be called by the program generated by ../reflect.go.
 
-// InterfaceFromInterfaceType returns a pointer to an interface for the
-// given reflection interface type.
-func InterfaceFromInterfaceType(it reflect.Type) (*Interface, error) {
-	if it.Kind() != reflect.Interface {
-		return nil, fmt.Errorf("%v is not an interface", it)
-	}
+// InterfaceFromInterfaceOrFuncType returns a pointer to an interface for the
+// given reflection interface or function type.
+func InterfaceFromInterfaceOrFuncType(it reflect.Type) (*Interface, error) {
 	intf := &Interface{}
 
-	for i := 0; i < it.NumMethod(); i++ {
-		mt := it.Method(i)
-		// TODO: need to skip unexported methods? or just raise an error?
+	switch it.Kind() {
+	case reflect.Interface:
+		for i := 0; i < it.NumMethod(); i++ {
+			mt := it.Method(i)
+			// TODO: need to skip unexported methods? or just raise an error?
+			m := &Method{
+				Name: mt.Name,
+			}
+
+			var err error
+			m.In, m.Variadic, m.Out, err = funcArgsFromType(mt.Type)
+			if err != nil {
+				return nil, err
+			}
+
+			intf.Methods = append(intf.Methods, m)
+		}
+	case reflect.Func:
+		// For function types, generate an interface having a single
+		// "Call" method.
 		m := &Method{
-			Name: mt.Name,
+			Name: "Call",
 		}
 
 		var err error
-		m.In, m.Variadic, m.Out, err = funcArgsFromType(mt.Type)
+		m.In, m.Variadic, m.Out, err = funcArgsFromType(it)
 		if err != nil {
 			return nil, err
 		}
 
 		intf.Methods = append(intf.Methods, m)
+	default:
+		return nil, fmt.Errorf("%v is not an interface or function type", it)
 	}
 
 	return intf, nil
diff --git mockgen/parse.go mockgen/parse.go
index a8edde8..8610fdc 100644
--- mockgen/parse.go
+++ mockgen/parse.go
@@ -144,7 +144,7 @@ func (p *fileParser) addAuxInterfacesFromFile(pkg string, file *ast.File) {
 	if _, ok := p.auxInterfaces[pkg]; !ok {
 		p.auxInterfaces[pkg] = make(map[string]*ast.InterfaceType)
 	}
-	for ni := range iterInterfaces(file) {
+	for _, ni := range extractInterfaces(file) {
 		p.auxInterfaces[pkg][ni.name.Name] = ni.it
 	}
 }
@@ -171,8 +171,22 @@ func (p *fileParser) parseFile(importPath string, file *ast.File) (*model.Packag
 	}
 
 	var is []*model.Interface
-	for ni := range iterInterfaces(file) {
-		i, err := p.parseInterface(ni.name.String(), importPath, ni.it)
+	for _, ni := range extractInterfaces(file) {
+		i, err := p.parseInterface(ni.name.String(), importPath, ni.it.Methods.List)
+		if err != nil {
+			return nil, err
+		}
+		is = append(is, i)
+	}
+	for _, ni := range extractFuncs(file) {
+		// For function types, generate an interface having a single
+		// "Call" method.
+		i, err := p.parseInterface(ni.name.String(), importPath, []*ast.Field{
+			{
+				Names: []*ast.Ident{{Name: "Call"}},
+				Type:  ni.ft,
+			},
+		})
 		if err != nil {
 			return nil, err
 		}
@@ -200,7 +214,7 @@ func (p *fileParser) parsePackage(path string) error {
 		if _, ok := p.importedInterfaces[path]; !ok {
 			p.importedInterfaces[path] = make(map[string]*ast.InterfaceType)
 		}
-		for ni := range iterInterfaces(file) {
+		for _, ni := range extractInterfaces(file) {
 			p.importedInterfaces[path][ni.name.Name] = ni.it
 		}
 		imports, _ := importsOfFile(file)
@@ -213,9 +227,9 @@ func (p *fileParser) parsePackage(path string) error {
 	return nil
 }
 
-func (p *fileParser) parseInterface(name, pkg string, it *ast.InterfaceType) (*model.Interface, error) {
+func (p *fileParser) parseInterface(name, pkg string, fields []*ast.Field) (*model.Interface, error) {
 	intf := &model.Interface{Name: name}
-	for _, field := range it.Methods.List {
+	for _, field := range fields {
 		switch v := field.Type.(type) {
 		case *ast.FuncType:
 			if nn := len(field.Names); nn != 1 {
@@ -238,7 +252,7 @@ func (p *fileParser) parseInterface(name, pkg string, it *ast.InterfaceType) (*m
 					return nil, p.errorf(v.Pos(), "unknown embedded interface %s", v.String())
 				}
 			}
-			eintf, err := p.parseInterface(v.String(), pkg, ei)
+			eintf, err := p.parseInterface(v.String(), pkg, ei.Methods.List)
 			if err != nil {
 				return nil, err
 			}
@@ -264,7 +278,7 @@ func (p *fileParser) parseInterface(name, pkg string, it *ast.InterfaceType) (*m
 					return nil, p.errorf(v.Pos(), "unknown embedded interface %s.%s", fpkg, sel)
 				}
 			}
-			eintf, err := p.parseInterface(sel, fpkg, ei)
+			eintf, err := p.parseInterface(sel, fpkg, ei.Methods.List)
 			if err != nil {
 				return nil, err
 			}
@@ -484,31 +498,53 @@ type namedInterface struct {
 	it   *ast.InterfaceType
 }
 
-// Create an iterator over all interfaces in file.
-func iterInterfaces(file *ast.File) <-chan namedInterface {
-	ch := make(chan namedInterface)
-	go func() {
-		for _, decl := range file.Decls {
-			gd, ok := decl.(*ast.GenDecl)
-			if !ok || gd.Tok != token.TYPE {
+// Extracts all interfaces from a file.
+func extractInterfaces(file *ast.File) (interfaces []namedInterface) {
+	for _, decl := range file.Decls {
+		gd, ok := decl.(*ast.GenDecl)
+		if !ok || gd.Tok != token.TYPE {
+			continue
+		}
+		for _, spec := range gd.Specs {
+			ts, ok := spec.(*ast.TypeSpec)
+			if !ok {
 				continue
 			}
-			for _, spec := range gd.Specs {
-				ts, ok := spec.(*ast.TypeSpec)
-				if !ok {
-					continue
-				}
-				it, ok := ts.Type.(*ast.InterfaceType)
-				if !ok {
-					continue
-				}
+			it, ok := ts.Type.(*ast.InterfaceType)
+			if !ok {
+				continue
+			}
+			interfaces = append(interfaces, namedInterface{ts.Name, it})
+		}
+	}
+	return
+}
 
-				ch <- namedInterface{ts.Name, it}
+type namedFunc struct {
+	name *ast.Ident
+	ft   *ast.FuncType
+}
+
+// Extracts all function types from a file.
+func extractFuncs(file *ast.File) (funcs []namedFunc) {
+	for _, decl := range file.Decls {
+		gd, ok := decl.(*ast.GenDecl)
+		if !ok || gd.Tok != token.TYPE {
+			continue
+		}
+		for _, spec := range gd.Specs {
+			ts, ok := spec.(*ast.TypeSpec)
+			if !ok {
+				continue
 			}
+			ft, ok := ts.Type.(*ast.FuncType)
+			if !ok {
+				continue
+			}
+			funcs = append(funcs, namedFunc{ts.Name, ft})
 		}
-		close(ch)
-	}()
-	return ch
+	}
+	return
 }
 
 // isVariadic returns whether the function is variadic.
diff --git mockgen/reflect.go mockgen/reflect.go
index 55c2450..567c45a 100644
--- mockgen/reflect.go
+++ mockgen/reflect.go
@@ -217,7 +217,7 @@ func main() {
 	}
 
 	for _, it := range its {
-		intf, err := model.InterfaceFromInterfaceType(it.typ)
+		intf, err := model.InterfaceFromInterfaceOrFuncType(it.typ)
 		if err != nil {
 			fmt.Fprintf(os.Stderr, "Reflection: %v\n", err)
 			os.Exit(1)

diff --git mockgen/model/model.go mockgen/model/model.go
index 94d7f4b..abc0cfd 100644
--- mockgen/model/model.go
+++ mockgen/model/model.go
@@ -335,28 +335,44 @@ func (tp *TypeParametersType) addImports(im map[string]bool) {
 
 // The following code is intended to be called by the program generated by ../reflect.go.
 
-// InterfaceFromInterfaceType returns a pointer to an interface for the
-// given reflection interface type.
-func InterfaceFromInterfaceType(it reflect.Type) (*Interface, error) {
-	if it.Kind() != reflect.Interface {
-		return nil, fmt.Errorf("%v is not an interface", it)
-	}
+// InterfaceFromInterfaceOrFuncType returns a pointer to an interface for the
+// given reflection interface or function type.
+func InterfaceFromInterfaceOrFuncType(it reflect.Type) (*Interface, error) {
 	intf := &Interface{}
 
-	for i := 0; i < it.NumMethod(); i++ {
-		mt := it.Method(i)
-		// TODO: need to skip unexported methods? or just raise an error?
+	switch it.Kind() {
+	case reflect.Interface:
+		for i := 0; i < it.NumMethod(); i++ {
+			mt := it.Method(i)
+			// TODO: need to skip unexported methods? or just raise an error?
+			m := &Method{
+				Name: mt.Name,
+			}
+
+			var err error
+			m.In, m.Variadic, m.Out, err = funcArgsFromType(mt.Type)
+			if err != nil {
+				return nil, err
+			}
+
+			intf.AddMethod(m)
+		}
+	case reflect.Func:
+		// For function types, generate an interface having a single
+		// "Call" method.
 		m := &Method{
-			Name: mt.Name,
+			Name: "Call",
 		}
 
 		var err error
-		m.In, m.Variadic, m.Out, err = funcArgsFromType(mt.Type)
+		m.In, m.Variadic, m.Out, err = funcArgsFromType(it)
 		if err != nil {
 			return nil, err
 		}
 
 		intf.AddMethod(m)
+	default:
+		return nil, fmt.Errorf("%v is not an interface or function type", it)
 	}
 
 	return intf, nil
diff --git mockgen/parse.go mockgen/parse.go
index 21c0d70..98ce222 100644
--- mockgen/parse.go
+++ mockgen/parse.go
@@ -201,8 +201,8 @@ func (p *fileParser) parseAuxFiles(auxFiles string) error {
 }
 
 func (p *fileParser) addAuxInterfacesFromFile(pkg string, file *ast.File) {
-	for ni := range iterInterfaces(file) {
-		p.auxInterfaces.Set(pkg, ni.name.Name, ni)
+	for _, ni := range extractInterfaces(file) {
+		p.auxInterfaces.Set(pkg, ni.name.Name, &ni)
 	}
 }
 
@@ -228,8 +228,22 @@ func (p *fileParser) parseFile(importPath string, file *ast.File) (*model.Packag
 	}
 
 	var is []*model.Interface
-	for ni := range iterInterfaces(file) {
-		i, err := p.parseInterface(ni.name.String(), importPath, ni)
+	for _, ni := range extractInterfaces(file) {
+		i, err := p.parseInterface(ni.name.String(), importPath, ni.typeParams, ni.it.Methods.List)
+		if err != nil {
+			return nil, err
+		}
+		is = append(is, i)
+	}
+	for _, ni := range extractFuncs(file) {
+		// For function types, generate an interface having a single
+		// "Call" method.
+		i, err := p.parseInterface(ni.name.String(), importPath, nil, []*ast.Field{
+			{
+				Names: []*ast.Ident{{Name: "Call"}},
+				Type:  ni.ft,
+			},
+		})
 		if err != nil {
 			return nil, err
 		}
@@ -263,8 +277,8 @@ func (p *fileParser) parsePackage(path string) (*fileParser, error) {
 
 	for _, pkg := range pkgs {
 		file := ast.MergePackageFiles(pkg, ast.FilterFuncDuplicates|ast.FilterUnassociatedComments|ast.FilterImportDuplicates)
-		for ni := range iterInterfaces(file) {
-			newP.importedInterfaces.Set(path, ni.name.Name, ni)
+		for _, ni := range extractInterfaces(file) {
+			newP.importedInterfaces.Set(path, ni.name.Name, &ni)
 		}
 		imports, _ := importsOfFile(file)
 		for pkgName, pkgI := range imports {
@@ -274,11 +288,11 @@ func (p *fileParser) parsePackage(path string) (*fileParser, error) {
 	return newP, nil
 }
 
-func (p *fileParser) parseInterface(name, pkg string, it *namedInterface) (*model.Interface, error) {
+func (p *fileParser) parseInterface(name, pkg string, typeParams []*ast.Field, fields []*ast.Field) (*model.Interface, error) {
 	iface := &model.Interface{Name: name}
 	tps := make(map[string]bool)
 
-	tp, err := p.parseFieldList(pkg, it.typeParams, tps)
+	tp, err := p.parseFieldList(pkg, typeParams, tps)
 	if err != nil {
 		return nil, fmt.Errorf("unable to parse interface type parameters: %v", name)
 	}
@@ -287,7 +301,7 @@ func (p *fileParser) parseInterface(name, pkg string, it *namedInterface) (*mode
 		tps[v.Name] = true
 	}
 
-	for _, field := range it.it.Methods.List {
+	for _, field := range fields {
 		switch v := field.Type.(type) {
 		case *ast.FuncType:
 			if nn := len(field.Names); nn != 1 {
@@ -312,7 +326,7 @@ func (p *fileParser) parseInterface(name, pkg string, it *namedInterface) (*mode
 			var embeddedIface *model.Interface
 			if embeddedIfaceType != nil {
 				var err error
-				embeddedIface, err = p.parseInterface(v.String(), pkg, embeddedIfaceType)
+				embeddedIface, err = p.parseInterface(v.String(), pkg, embeddedIfaceType.typeParams, embeddedIfaceType.it.Methods.List)
 				if err != nil {
 					return nil, err
 				}
@@ -330,7 +344,7 @@ func (p *fileParser) parseInterface(name, pkg string, it *namedInterface) (*mode
 						return nil, p.errorf(v.Pos(), "unknown embedded interface %s.%s", pkg, v.String())
 					}
 
-					embeddedIface, err = ip.parseInterface(v.String(), pkg, embeddedIfaceType)
+					embeddedIface, err = ip.parseInterface(v.String(), pkg, embeddedIfaceType.typeParams, embeddedIfaceType.it.Methods.List)
 					if err != nil {
 						return nil, err
 					}
@@ -352,7 +366,7 @@ func (p *fileParser) parseInterface(name, pkg string, it *namedInterface) (*mode
 			var err error
 			embeddedIfaceType := p.auxInterfaces.Get(filePkg, sel)
 			if embeddedIfaceType != nil {
-				embeddedIface, err = p.parseInterface(sel, filePkg, embeddedIfaceType)
+				embeddedIface, err = p.parseInterface(sel, filePkg, embeddedIfaceType.typeParams, embeddedIfaceType.it.Methods.List)
 				if err != nil {
 					return nil, err
 				}
@@ -373,7 +387,7 @@ func (p *fileParser) parseInterface(name, pkg string, it *namedInterface) (*mode
 				if embeddedIfaceType = parser.importedInterfaces.Get(path, sel); embeddedIfaceType == nil {
 					return nil, p.errorf(v.Pos(), "unknown embedded interface %s.%s", path, sel)
 				}
-				embeddedIface, err = parser.parseInterface(sel, path, embeddedIfaceType)
+				embeddedIface, err = parser.parseInterface(sel, path, embeddedIfaceType.typeParams, embeddedIfaceType.it.Methods.List)
 				if err != nil {
 					return nil, err
 				}
@@ -662,31 +676,54 @@ type namedInterface struct {
 	typeParams []*ast.Field
 }
 
-// Create an iterator over all interfaces in file.
-func iterInterfaces(file *ast.File) <-chan *namedInterface {
-	ch := make(chan *namedInterface)
-	go func() {
-		for _, decl := range file.Decls {
-			gd, ok := decl.(*ast.GenDecl)
-			if !ok || gd.Tok != token.TYPE {
+// Extracts all interfaces from a file.
+func extractInterfaces(file *ast.File) (interfaces []namedInterface) {
+	for _, decl := range file.Decls {
+		gd, ok := decl.(*ast.GenDecl)
+		if !ok || gd.Tok != token.TYPE {
+			continue
+		}
+		for _, spec := range gd.Specs {
+			ts, ok := spec.(*ast.TypeSpec)
+			if !ok {
+				continue
+			}
+			it, ok := ts.Type.(*ast.InterfaceType)
+			if !ok {
 				continue
 			}
-			for _, spec := range gd.Specs {
-				ts, ok := spec.(*ast.TypeSpec)
-				if !ok {
-					continue
-				}
-				it, ok := ts.Type.(*ast.InterfaceType)
-				if !ok {
-					continue
-				}
 
-				ch <- &namedInterface{ts.Name, it, getTypeSpecTypeParams(ts)}
+			interfaces = append(interfaces, namedInterface{ts.Name, it, getTypeSpecTypeParams(ts)})
+		}
+	}
+	return
+}
+
+type namedFunc struct {
+	name *ast.Ident
+	ft   *ast.FuncType
+}
+
+// Extracts all function types from a file.
+func extractFuncs(file *ast.File) (funcs []namedFunc) {
+	for _, decl := range file.Decls {
+		gd, ok := decl.(*ast.GenDecl)
+		if !ok || gd.Tok != token.TYPE {
+			continue
+		}
+		for _, spec := range gd.Specs {
+			ts, ok := spec.(*ast.TypeSpec)
+			if !ok {
+				continue
 			}
+			ft, ok := ts.Type.(*ast.FuncType)
+			if !ok {
+				continue
+			}
+			funcs = append(funcs, namedFunc{ts.Name, ft})
 		}
-		close(ch)
-	}()
-	return ch
+	}
+	return
 }
 
 // isVariadic returns whether the function is variadic.
diff --git mockgen/reflect.go mockgen/reflect.go
index 4f86a15..c84c49f 100644
--- mockgen/reflect.go
+++ mockgen/reflect.go
@@ -224,7 +224,7 @@ func main() {
 	}
 
 	for _, it := range its {
-		intf, err := model.InterfaceFromInterfaceType(it.typ)
+		intf, err := model.InterfaceFromInterfaceOrFuncType(it.typ)
 		if err != nil {
 			fmt.Fprintf(os.Stderr, "Reflection: %v\n", err)
 			os.Exit(1)
